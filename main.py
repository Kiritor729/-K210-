# generated by maixhub, tested on maixpy3 v0.4.8
# copy files to TF card and plug into board and power on
import sensor, image, lcd, time
import KPU as kpu
from machine import UART,Timer

import gc, sys
from fpioa_manager import fm

#映射串口引脚
fm.register(6, fm.fpioa.UART1_RX, force=True)
fm.register(7, fm.fpioa.UART1_TX, force=True)




#初始化串口
uart = UART(UART.UART1, 9600, read_buf_len=4096)




input_size = (224, 224)
labels = ['Apple', 'unrip']
anchors = [0.66, 0.66, 0.47, 0.47, 0.31, 0.28, 0.97, 0.94, 1.56, 1.59]


# 定义SYN6288模块的命令
SYN_StopCom = b'\xFD\x00\x02\x02\xFD'
SYN_SuspendCom = b'\xFD\x00\x02\x03\xFC'
SYN_RecoverCom = b'\xFD\x00\x02\x04\xFB'
SYN_ChackCom = b'\xFD\x00\x02\x21\xDE'
SYN_PowerDownCom = b'\xFD\x00\x02\x88\x77'


class Button(object):
    DEBOUNCE_THRESHOLD = 30
    LONG_PRESS_THRESHOLD = 2000
    # Internal  key states
    IDLE = 0
    DEBOUNCE = 1
    SHORT_PRESS = 2
    LONG_PRESS = 3

    def __init__(self):
        self._state = Button.IDLE
        self._key_ticks = 0
        self._pre_key_state = 1
        self.SHORT_PRESS_BUFF = None

    def reset(self):
        self._state = Button.IDLE
        self._key_ticks = 0
        self._pre_key_state = 1
        self.SHORT_PRESS_BUFF = None

    def key_up(self, delta):
        global state_machine
        # print("up:{}".format(delta))
        # key up时，有缓存的key信息就发出去，没有的话直接复位状态
        if self.SHORT_PRESS_BUFF:
            state_machine.emit_event(self.SHORT_PRESS_BUFF)
        self.reset()

    def key_down(self, delta):
        global state_machine
        # print("dn:{},t:{}".format(delta, self._key_ticks))
        if self._state == Button.IDLE:
            self._key_ticks += delta
            if self._key_ticks > Button.DEBOUNCE_THRESHOLD:
                # main loop period过大时，会直接跳过去抖阶段
                self._state = Button.SHORT_PRESS
                self.SHORT_PRESS_BUFF = EVENT.BOOT_KEY  # key_up 时发送
            else:
                self._state = Button.DEBOUNCE
        elif self._state == Button.DEBOUNCE:
            self._key_ticks += delta
            if self._key_ticks > Button.DEBOUNCE_THRESHOLD:
                self._state = Button.SHORT_PRESS
                self.SHORT_PRESS_BUFF = EVENT.BOOT_KEY  # key_up 时发送
        elif self._state == Button.SHORT_PRESS:
            self._key_ticks += delta
            if self._key_ticks > Button.LONG_PRESS_THRESHOLD:
                self._state = Button.LONG_PRESS
                self.SHORT_PRESS_BUFF = None  # 检测到长按，将之前可能存在的短按buffer清除，以防发两个key event出去
                state_machine.emit_event(EVENT.BOOT_KEY_LONG_PRESS)
        elif self._state == Button.LONG_PRESS:
            self._key_ticks += delta
            # 最迟 LONG_PRESS 发出信号，再以后就忽略，不需要处理。key_up时再退出状态机。
            pass
        else:
            pass

# 发送单个字节数据
def uart_send_byte(byte):
    uart.write(byte)

# 发送字符串数据
def uart_send_string(data):
    uart.write(data)

# 发送SYN6288的帧信息
def syn_frame_info(music, text):
    # 计算文本长度
    hz_length = len(text)
    frame_info = bytearray(hz_length+6)
    frame_info[0] = 0xFD
    frame_info[1] = 0x00
    frame_info[2] = hz_length + 3
    frame_info[3] = 0x01
    frame_info[4] = 0x01 | (music << 4)

    # 计算校验码
    ecc = 0
    for i in range(5):
        ecc ^= frame_info[i]
        i += 1
    i = 0
    for char in text:
        frame_info[i+5] = char
        i += 1
    for i in range(hz_length):
        ecc ^= frame_info[i+5]
        i += 1
    # 发送帧信息
    frame_info[hz_length+5] = ecc
    uart_send_string(frame_info)
#    for j in (5 + hz_length):
    print(frame_info)

# 设置SYN6288模块
def ys_syn_set(info_data):
    uart_send_string(info_data)

# 延时函数
def delay(ms):
    time.sleep_ms(ms)

def lcd_show_except(e):
    import uio
    err_str = uio.StringIO()
    sys.print_exception(e, err_str)
    err_str = err_str.getvalue()
    img = image.Image(size=input_size)
    img.draw_string(0, 10, err_str, scale=1, color=(0xff,0x00,0x00))
    lcd.display(img)

class Comm:
    def __init__(self, uart):
        self.uart = uart

    def send_detect_result(self, objects, labels):
        msg = ""
        for obj in objects:
            pos = obj.rect()
            p = obj.value()
            idx = obj.classid()
            label = labels[idx]
            msg += "{}:{}:{}:{}:{}:{:.2f}:{}, ".format(pos[0], pos[1], pos[2], pos[3], idx, p, label)
        if msg:
            msg = msg[:-2] + "\n"
        self.uart.write(msg.encode())

i = 0
def delay_yolo(x,task):
    for i in range(x):

        i += 1;
        img = sensor.snapshot()
        t = time.ticks_ms()
        objects = kpu.run_yolo2(task, img)
        if objects != None:
            print("obj :", objects)
        t = time.ticks_ms() - t
        ripe = 0
        unripe = 0
        if objects:
            for obj in objects:
                pos = obj.rect()
                img.draw_rectangle(pos)
                img.draw_string(pos[0], pos[1], "%s : %.2f" %(labels[obj.classid()], obj.value()), scale=1.2, color=(255, 0, 0))
                print("num :", obj.objnum())
                print("class :", obj.classid())
                if obj.classid() == 0:
                    ripe += 1
                    uart.write( "7")
                elif obj.classid() == 1:
                    uart.write( "11")
                    unripe +=1
            #comm.send_detect_result(objects, labels)

            img.draw_string(0, 2, "RipeApple:%d" %(ripe), scale=1.2, color=(255, 0, 0))
            img.draw_string(0, 20, "Unripe:%d" %(unripe), scale=1.2, color=(255, 0, 0))
            img.draw_string(0, 40, "Total: %d"  %(obj.objnum()), scale=2, color=(255, 0, 0))
            img.draw_string(0, 200, "fps:%dms" %(t), scale=2, color=(255, 0, 0))
            lcd.display(img)
        gc.collect()


def main(anchors, labels = None, model_addr="/sd/m.kmodel", sensor_window=input_size, lcd_rotation=0, sensor_hmirror=False, sensor_vflip=False):


    sensor.reset()
    sensor.set_pixformat(sensor.RGB565)
    sensor.set_framesize(sensor.QVGA)
    #sensor.set_windowing(sensor_window)
    sensor.set_windowing((224,224))
    sensor.set_hmirror(sensor_hmirror)
    sensor.set_vflip(sensor_vflip)
    sensor.run(1)

    lcd.init(type=1)
    lcd.rotation(lcd_rotation)
    lcd.clear(lcd.WHITE)

    if not labels:
        with open('labels.txt','r') as f:
            exec(f.read())
    if not labels:
        print("no labels.txt")
        img = image.Image(size=(320, 240))
        img.draw_string(90, 110, "no labels.txt", color=(255, 0, 0), scale=2)
        lcd.display(img)
        return 1
    try:
        img = image.Image("startup.jpg")
        lcd.display(img)
    except Exception:
        img = image.Image(size=(320, 240))
        img.draw_string(90, 110, "loading model...", color=(255, 255, 255), scale=2)
        lcd.display(img)


    comm = Comm(uart)


    try:


        task = None
        task = kpu.load(0x300000, 1906856)
        #task = kpu.load(model_addr)
        kpu.init_yolo2(task, 0.5, 0.3, 5, anchors) # threshold:[0,1], nms_value: [0, 1]
        j = 0
        a = 9
        b = 9
        c = 9
        while True:
            #uart.write("11") #数据回传
            img = sensor.snapshot()
            t = time.ticks_ms()
            objects = kpu.run_yolo2(task, img)
            if objects != None:
                print("obj :", objects)
            t = time.ticks_ms() - t
            ripe = 0
            unripe = 0

            if objects:#有检测到
                for obj in objects:#画框
                    pos = obj.rect()
                    img.draw_rectangle(pos)
                    img.draw_string(pos[0], pos[1], "%s : %.2f" %(labels[obj.classid()], obj.value()), scale=1.2, color=(255, 0, 0))
                    print("num :", obj.objnum())
                    print("class :", obj.classid())
                    if obj.classid() == 0:
                        ripe += 1
                        uart.write( "7")
                    elif obj.classid() == 1:
                        uart.write( "11")
                        unripe +=1
                # comm.send_detect_result(objects, labels)
                #计数
                img.draw_string(0, 2, "RipeApple:%d" %(ripe), scale=1.2, color=(255, 0, 0))
                img.draw_string(0, 20, "Unripe:%d" %(unripe), scale=1.2, color=(255, 0, 0))
                img.draw_string(0, 40, "Total: %d"  %(obj.objnum()), scale=2, color=(255, 0, 0))

                if a == ripe and b == unripe:
                    j += 2
                a = ripe
                b = unripe
                c = ripe + unripe
                if j > 30999:
                    # 语音

                    a = ripe
                    b = unripe
                    c = ripe + unripe
                    data1 = bytearray([
                    0xFD, 0x00, 0x0D, 0x01, 0x01, 0x5B, 0x76, 0x31,
                    0x5D, 0x5B, 0x74, 0x35, 0x5D, 0xCA, 0xEC, 0xD0])#熟
                    data2 = bytearray([
                    0xFD, 0x00, 0x0D, 0x01, 0x01, 0x5B, 0x76, 0x31,
                    0x5D, 0x5B, 0x74, 0x35, 0x5D, 0xC9, 0xFA, 0xC5])#生
                    data3 = bytearray([
                    0xFD, 0x00, 0x0F, 0x01, 0x01, 0x5B, 0x76, 0x31,
                    0x5D, 0x5B, 0x74, 0x35, 0x5D, 0xB7, 0xAC, 0xC7, 0xD1, 0xF9])#番茄
                    data4 = bytearray([
                    0xFD, 0x00, 0x0F, 0x01, 0x01, 0x5B, 0x76, 0x31,
                    0x5D, 0x5B, 0x74, 0x35, 0x5D, 0xD7, 0xDC, 0xB9, 0xB2, 0xF4])#总共
                    data5 = bytearray([
                    0xFD, 0x00, 0x0D, 0x01, 0x01, 0x5B, 0x76, 0x31,
                    0x5D, 0x5B, 0x74, 0x35, 0x5D, 0xB8, 0xF6, 0xB8])#个

                    #熟番茄
                    uart_send_string(data1)
                    delay_yolo(10,task)
                    uart_send_string(data1)
                    delay_yolo(10,task)
                    uart_send_string(data3)
                    delay_yolo(20,task)
                    syn_frame_info(0, b"[v1][t5]%d"%a)
                    delay_yolo(10,task)
                    uart_send_string(data5)
                    delay_yolo(20,task)
                    #生番茄
                    uart_send_string(data2)
                    delay_yolo(10,task)
                    uart_send_string(data3)
                    delay_yolo(20,task)
                    syn_frame_info(0, b"[v1][t5]%d"%b)
                    delay_yolo(10,task)
                    uart_send_string(data5)
                    delay_yolo(20,task)
                    #总共
                    uart_send_string(data4)
                    delay_yolo(10,task)
                    syn_frame_info(0, b"[v1][t5]%d"%c)
                    delay_yolo(10,task)
                    uart_send_string(data5)
                    delay_yolo(20,task)
                    #清零
                    j = 0
                if j > 0:
                    j -= 1
                ripe = 0
                unripe = 0
                #total = obj[objnum]
               # img.draw_string(0, 40, "Total：",total )
            #img.draw_string(0, 2, "Upgrade to MaixCAM to use YOLOv8", scale=1.2, color=(255, 0, 0))
            #img.draw_string(0, 30, "wiki.sipeed.com/maixcam", scale=1.2, color=(255, 0, 0))
            img.draw_string(0, 200, "FPS:%dms" %(t), scale=2, color=(255, 0, 0))
            lcd.display(img)
            gc.collect()
    except Exception as e:
        raise e
    finally:
        if not task is None:
            kpu.deinit(task)


if __name__ == "__main__":

    try:
         main(anchors = anchors, labels=labels, model_addr=0x300000, lcd_rotation=0)
        #main(anchors = anchors, labels=labels, model_addr="/sd/model-148396.kmodel")
    except Exception as e:
        sys.print_exception(e)
        lcd_show_except(e)
    finally:
        gc.collect()
